{"ast":null,"code":"import { sync } from '../../frameloop/index.mjs';\nimport { transformProps } from '../../render/html/utils/transform.mjs';\nimport { appearStoreId } from './store-id.mjs';\nfunction handoffOptimizedAppearAnimation(id, name, value) {\n  const {\n    MotionAppearAnimations\n  } = window;\n  const animationId = appearStoreId(id, transformProps.has(name) ? \"transform\" : name);\n  const animation = MotionAppearAnimations && MotionAppearAnimations.get(animationId);\n  if (animation) {\n    const sampledTime = performance.now();\n    /**\r\n     * Resync handoff animation with optimised animation.\r\n     *\r\n     * This step would be unnecessary if we triggered animateChanges() in useEffect,\r\n     * but due to potential hydration errors we currently fire them in useLayoutEffect.\r\n     *\r\n     * By the time we're safely ready to cancel the optimised WAAPI animation,\r\n     * the main thread might have been blocked and desynced the two animations.\r\n     *\r\n     * Here, we resync the two animations before the optimised WAAPI animation is cancelled.\r\n     */\n    sync.update(() => {\n      if (value.animation) {\n        value.animation.currentTime = performance.now() - sampledTime;\n      }\n    });\n    /**\r\n     * We allow the animation to persist until the next frame:\r\n     *   1. So it continues to play until Framer Motion is ready to render\r\n     *      (avoiding a potential flash of the element's original state)\r\n     *   2. As all independent transforms share a single transform animation, stopping\r\n     *      it synchronously would prevent subsequent transforms from handing off.\r\n     */\n    sync.render(() => {\n      MotionAppearAnimations.delete(animationId);\n      /**\r\n       * Animation.cancel() throws so it needs to be wrapped in a try/catch\r\n       */\n      try {\n        animation.cancel();\n      } catch (e) {}\n    });\n    return animation.currentTime || 0;\n  } else {\n    return 0;\n  }\n}\nexport { handoffOptimizedAppearAnimation };","map":{"version":3,"names":["sync","transformProps","appearStoreId","handoffOptimizedAppearAnimation","id","name","value","MotionAppearAnimations","window","animationId","has","animation","get","sampledTime","performance","now","update","currentTime","render","delete","cancel","e"],"sources":["C:/Users/HP/Alumni-Cell-Yearbook-Portal/client/node_modules/framer-motion/dist/es/animation/optimized-appear/handoff.mjs"],"sourcesContent":["import { sync } from '../../frameloop/index.mjs';\r\nimport { transformProps } from '../../render/html/utils/transform.mjs';\r\nimport { appearStoreId } from './store-id.mjs';\r\n\r\nfunction handoffOptimizedAppearAnimation(id, name, value) {\r\n    const { MotionAppearAnimations } = window;\r\n    const animationId = appearStoreId(id, transformProps.has(name) ? \"transform\" : name);\r\n    const animation = MotionAppearAnimations && MotionAppearAnimations.get(animationId);\r\n    if (animation) {\r\n        const sampledTime = performance.now();\r\n        /**\r\n         * Resync handoff animation with optimised animation.\r\n         *\r\n         * This step would be unnecessary if we triggered animateChanges() in useEffect,\r\n         * but due to potential hydration errors we currently fire them in useLayoutEffect.\r\n         *\r\n         * By the time we're safely ready to cancel the optimised WAAPI animation,\r\n         * the main thread might have been blocked and desynced the two animations.\r\n         *\r\n         * Here, we resync the two animations before the optimised WAAPI animation is cancelled.\r\n         */\r\n        sync.update(() => {\r\n            if (value.animation) {\r\n                value.animation.currentTime = performance.now() - sampledTime;\r\n            }\r\n        });\r\n        /**\r\n         * We allow the animation to persist until the next frame:\r\n         *   1. So it continues to play until Framer Motion is ready to render\r\n         *      (avoiding a potential flash of the element's original state)\r\n         *   2. As all independent transforms share a single transform animation, stopping\r\n         *      it synchronously would prevent subsequent transforms from handing off.\r\n         */\r\n        sync.render(() => {\r\n            MotionAppearAnimations.delete(animationId);\r\n            /**\r\n             * Animation.cancel() throws so it needs to be wrapped in a try/catch\r\n             */\r\n            try {\r\n                animation.cancel();\r\n            }\r\n            catch (e) { }\r\n        });\r\n        return animation.currentTime || 0;\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\n\r\nexport { handoffOptimizedAppearAnimation };\r\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,2BAA2B;AAChD,SAASC,cAAc,QAAQ,uCAAuC;AACtE,SAASC,aAAa,QAAQ,gBAAgB;AAE9C,SAASC,+BAA+B,CAACC,EAAE,EAAEC,IAAI,EAAEC,KAAK,EAAE;EACtD,MAAM;IAAEC;EAAuB,CAAC,GAAGC,MAAM;EACzC,MAAMC,WAAW,GAAGP,aAAa,CAACE,EAAE,EAAEH,cAAc,CAACS,GAAG,CAACL,IAAI,CAAC,GAAG,WAAW,GAAGA,IAAI,CAAC;EACpF,MAAMM,SAAS,GAAGJ,sBAAsB,IAAIA,sBAAsB,CAACK,GAAG,CAACH,WAAW,CAAC;EACnF,IAAIE,SAAS,EAAE;IACX,MAAME,WAAW,GAAGC,WAAW,CAACC,GAAG,EAAE;IACrC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQf,IAAI,CAACgB,MAAM,CAAC,MAAM;MACd,IAAIV,KAAK,CAACK,SAAS,EAAE;QACjBL,KAAK,CAACK,SAAS,CAACM,WAAW,GAAGH,WAAW,CAACC,GAAG,EAAE,GAAGF,WAAW;MACjE;IACJ,CAAC,CAAC;IACF;AACR;AACA;AACA;AACA;AACA;AACA;IACQb,IAAI,CAACkB,MAAM,CAAC,MAAM;MACdX,sBAAsB,CAACY,MAAM,CAACV,WAAW,CAAC;MAC1C;AACZ;AACA;MACY,IAAI;QACAE,SAAS,CAACS,MAAM,EAAE;MACtB,CAAC,CACD,OAAOC,CAAC,EAAE,CAAE;IAChB,CAAC,CAAC;IACF,OAAOV,SAAS,CAACM,WAAW,IAAI,CAAC;EACrC,CAAC,MACI;IACD,OAAO,CAAC;EACZ;AACJ;AAEA,SAASd,+BAA+B"},"metadata":{},"sourceType":"module","externalDependencies":[]}